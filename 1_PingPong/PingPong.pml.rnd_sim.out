  0:	proc  - (:root:) creates proc  0 (:init:)
ltl singleBallForever: <> ([] (((((len(chP1ToP2)+len(chP2ToP1))+pActiveBalls[0])+pActiveBalls[1])==1)))
ltl initiallyNoBallsMustNotFailForCredit: (((((len(chP1ToP2)+len(chP2ToP1))+pActiveBalls[0])+pActiveBalls[1])==0)) && ([] (1))
ltl allBallsCannotBeConstantMustNotFailForCredit: (((! ([] (((((len(chP1ToP2)+len(chP2ToP1))+pActiveBalls[0])+pActiveBalls[1])==0)))) && (! ([] (((((len(chP1ToP2)+len(chP2ToP1))+pActiveBalls[0])+pActiveBalls[1])==1))))) && (! ([] (((((len(chP1ToP2)+len(chP2ToP1))+pActiveBalls[0])+pActiveBalls[1])==2))))) && ([] (1))
Starting Referee with pid 1
  1:	proc  0 (:init::1) creates proc  1 (Referee)
  1:	proc  0 (:init::1) PingPong.pml:103 (state 1)	[(run Referee())]

  2:	proc  1 (Referee:1) PingPong.pml:35 (state -)	[values: 1!BALL]
  2:	proc  1 (Referee:1) PingPong.pml:35 (state 1)	[chRefToPs!BALL]
		queue 1 (chRefToPs): [BALL]

  2:	proc  1 (Referee:1) terminates
Starting Player1 with pid 1
  3:	proc  0 (:init::1) creates proc  1 (Player1)
  3:	proc  0 (:init::1) PingPong.pml:104 (state 2)	[(run Player1())]

hi I am player 1  4:	proc  1 (Player1:1) PingPong.pml:40 (state 1)	[printf('hi I am player 1')]

Starting Player2 with pid 2
  5:	proc  0 (:init::1) creates proc  2 (Player2)
  5:	proc  0 (:init::1) PingPong.pml:105 (state 3)	[(run Player2())]

  6:	proc  1 (Player1:1) PingPong.pml:70 (state 20)	[.(goto)]

  7:	proc  1 (Player1:1) PingPong.pml:47 (state 2)	[(nempty(chRefToPs))]

hi I am player 2  8:	proc  2 (Player2:1) PingPong.pml:73 (state 1)	[printf('hi I am player 2')]

  9:	proc  2 (Player2:1) PingPong.pml:100 (state 19)	[.(goto)]

 10:	proc  2 (Player2:1) PingPong.pml:79 (state 2)	[(nempty(chRefToPs))]

 11:	proc  2 (Player2:1) PingPong.pml:81 (state -)	[values: 1?BALL]
 11:	proc  2 (Player2:1) PingPong.pml:81 (state 3)	[chRefToPs?BALL]
		queue 1 (chRefToPs): 
 12:	proc  2 (Player2:1) PingPong.pml:82 (state 4)	[pActiveBalls[1] = 1]
		pActiveBalls[0] = 0
		pActiveBalls[1] = 1

P2 receives ball from ref 13:	proc  2 (Player2:1) PingPong.pml:84 (state 6)	[printf('P2 receives ball from ref')]

 14:	proc  2 (Player2:1) PingPong.pml:94 (state 13)	[.(goto)]

P2 receives from P1, send ball ... P2 -> P1 15:	proc  2 (Player2:1) PingPong.pml:94 (state 14)	[printf('P2 receives from P1, send ball ... P2 -> P1')]

 16:	proc  2 (Player2:1) PingPong.pml:96 (state -)	[values: 2!BALL]
 16:	proc  2 (Player2:1) PingPong.pml:96 (state 15)	[chP2ToP1!BALL]
		queue 2 (chP2ToP1): [BALL]
 17:	proc  2 (Player2:1) PingPong.pml:97 (state 16)	[pActiveBalls[1] = 0]
		pActiveBalls[0] = 0
		pActiveBalls[1] = 0

timeout
#processes: 3
		queue 3 (chP1ToP2): 
		queue 2 (chP2ToP1): [BALL]
		queue 1 (chRefToPs): 
		pActiveBalls[0] = 0
		pActiveBalls[1] = 0
 17:	proc  2 (Player2:1) PingPong.pml:75 (state 18)
 17:	proc  1 (Player1:1) PingPong.pml:48 (state 5)
 17:	proc  0 (:init::1) PingPong.pml:107 (state 4)
4 processes created
